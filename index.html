<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aether | The Continent Explorer</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,400&family=Montserrat:wght@200;300;400;500&display=swap" rel="stylesheet">

    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --accent-color: #ffd700;
        }

        * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Montserrat', sans-serif;
            color: var(--text-primary);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            outline: none;
        }

        /* UI Layer */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            z-index: 10;
        }

        /* Header */
        header {
            text-align: center;
            opacity: 0;
            transform: translateY(-20px);
            animation: fadeInDown 1.5s ease forwards 0.5s;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 4rem;
            font-weight: 300;
            margin: 0;
            letter-spacing: 0.1em;
            background: linear-gradient(to right, #fff, #a5a5a5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,255,255,0.2);
        }

        .subtitle {
            font-size: 0.9rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* Controls Area */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            pointer-events: none; /* Children will re-enable pointer-events */
        }

        .btn {
            pointer-events: auto;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 12px 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
            overflow: hidden;
            outline: none;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: 0.5s;
        }

        .btn:hover {
            background: var(--glass-highlight);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
            transform: translateY(-2px);
            border-color: rgba(255,255,255,0.3);
        }

        .btn:hover::before {
            left: 100%;
        }

        /* Info Card / Postcard */
        .info-card-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            max-width: 500px;
            pointer-events: none;
            perspective: 1000px;
            z-index: 20;
        }

        .info-card {
            background: rgba(15, 15, 25, 0.65);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            padding: 3rem;
            color: #fff;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            opacity: 0;
            transform: rotateX(10deg) translateY(50px) scale(0.9);
            transform-origin: center top;
            transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
        }

        /* Elegant border accent */
        .info-card::after {
            content: '';
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }

        .info-card.visible {
            opacity: 1;
            transform: rotateX(0) translateY(0) scale(1);
        }

        .info-card h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 3.5rem;
            font-weight: 300;
            margin: 0 0 1rem 0;
            line-height: 1;
            background: linear-gradient(45deg, #fff, #e0e0e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .info-card p {
            font-family: 'Montserrat', sans-serif;
            font-weight: 300;
            font-size: 1rem;
            line-height: 1.8;
            color: rgba(255,255,255,0.8);
            margin: 0;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
            z-index: 5;
        }

        .close-btn:hover {
            color: white;
        }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #020205;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .loader-text {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.5rem;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.5);
            animation: pulse 2s infinite;
        }

        /* Animations */
        @keyframes fadeInDown {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        /* Quiz Mode Styles */
        .quiz-hud {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .quiz-hud.visible {
            opacity: 1;
        }

        .quiz-question {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .quiz-score {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--accent-color);
        }

    </style>
</head>
<body>

    <!-- Loader -->
    <div id="loader">
        <div class="loader-text">INITIALIZING AETHER...</div>
    </div>

    <!-- UI Layer -->
    <div class="ui-layer">
        <header>
            <h1>AETHER</h1>
            <div class="subtitle">Interactive Planetary Archive</div>
        </header>

        <div id="quizHud" class="quiz-hud">
            <div class="quiz-question" id="quizQuestion">Where is Africa?</div>
            <div class="quiz-score" id="quizScore">Score: 0</div>
        </div>

        <div class="controls">
            <button id="resetBtn" class="btn">Return to Orbit</button>
            <button id="quizBtn" class="btn">Exploration Mode</button>
        </div>
    </div>

    <!-- Info Card -->
    <div class="info-card-container">
        <div id="infoCard" class="info-card">
            <button class="close-btn" id="closeCard">&times;</button>
            <h2 id="cardTitle">Continent</h2>
            <p id="cardText">Description text goes here...</p>
        </div>
    </div>

    <canvas id="webgl"></canvas>

    <!-- Scripts -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

        // --- SHADERS ---

        // Starfield Shader (Nebula background)
        const starfieldVertex = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec4 pos = vec4(position, 1.0);
                gl_Position = projectionMatrix * modelViewMatrix * pos;
            }
        `;

        const starfieldFragment = `
            uniform float time;
            varying vec2 vUv;

            // Simple noise function
            float noise(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            void main() {
                vec2 uv = vUv;

                // Deep space gradient
                vec3 color = mix(vec3(0.02, 0.02, 0.05), vec3(0.05, 0.05, 0.15), uv.y);

                // Stars
                float star = noise(uv * 100.0 + time * 0.05);
                if (star > 0.995) {
                    color += vec3(1.0) * (sin(time * 2.0 + uv.x * 100.0) * 0.5 + 0.5);
                }

                // Subtle nebula clouds (approximated with noise layers)
                float cloud = noise(uv * 3.0 + time * 0.02);
                color += vec3(0.1, 0.0, 0.2) * cloud * 0.3;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Planet Atmosphere Shader
        const atmosphereVertex = `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const atmosphereFragment = `
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                gl_FragColor = vec4(0.6, 0.8, 1.0, 1.0) * intensity;
            }
        `;

        // --- CONFIG ---
        const CONFIG = {
            colors: {
                bg: 0x050510,
                continentDefault: 0xffffff,
                continentHover: 0x89CFF0,
                africa: 0xFFDAB9,     // Peach Puff
                australia: 0xF4C2C2,  // Baby Pink
                antarctica: 0xE0FFFF, // Light Cyan
                europe: 0xB0E0E6,     // Powder Blue
                asia: 0xD8BFD8,       // Thistle
                northAmerica: 0x98FB98, // Pale Green
                southAmerica: 0xFFFACD  // Lemon Chiffon
            },
            radius: 5,
            camZ: 16
        };

        // --- STATE ---
        const state = {
            zoomed: false,
            animating: false,
            quizMode: false,
            score: 0,
            currentQuestion: null,
            hovered: null
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(CONFIG.colors.bg); // Using shader background instead

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ + 10; // Start far for intro

        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#webgl'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.enableZoom = false;
        controls.minDistance = 6;
        controls.maxDistance = 25;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(10, 10, 10);
        scene.add(mainLight);

        const rimLight = new THREE.DirectionalLight(0x4455ff, 1.0);
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // --- OBJECTS ---

        // 1. Background Starfield
        const starGeo = new THREE.SphereGeometry(100, 64, 64);
        const starMat = new THREE.ShaderMaterial({
            vertexShader: starfieldVertex,
            fragmentShader: starfieldFragment,
            uniforms: {
                time: { value: 0 }
            },
            side: THREE.BackSide
        });
        const starfield = new THREE.Mesh(starGeo, starMat);
        scene.add(starfield);

        // 2. Planet Core (The Orb)
        const planetGeo = new THREE.SphereGeometry(CONFIG.radius, 128, 128);
        const planetMat = new THREE.MeshPhysicalMaterial({
            color: 0x1a1a2e, // Deep blue-black
            roughness: 0.6,
            metalness: 0.2,
            clearcoat: 0.1,
            clearcoatRoughness: 0.4,
            sheen: 0.5,
            sheenColor: 0x4444ff,
        });
        const planet = new THREE.Mesh(planetGeo, planetMat);
        scene.add(planet);

        // 3. Atmosphere Glow
        const atmoGeo = new THREE.SphereGeometry(CONFIG.radius + 1.5, 64, 64);
        const atmoMat = new THREE.ShaderMaterial({
            vertexShader: atmosphereVertex,
            fragmentShader: atmosphereFragment,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true,
            opacity: 0.5
        });
        const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
        scene.add(atmosphere);

        // 4. Continents Group
        const continentsGroup = new THREE.Group();
        planet.add(continentsGroup); // Attach to planet so they rotate with it

        // --- DATA & GENERATION ---
        const continentsData = [
            {svgPath: "M553,307L550,298L548,289L542,283L531,273L524,272L517,264L500,265L494,258L475,252L465,244L453,235L441,230L423,230L411,237L403,232L399,223L403,215L402,204L410,195L413,184L424,175L425,166L433,158L430,147L420,138L421,126L415,119L418,109L425,100L423,89L418,80L405,73L394,66L384,60L380,51L387,42L387,32L397,25L407,17L418,11L415,3L406,1L375,1L359,6L343,9L338,18L329,22L319,26L310,21L301,23L294,29L289,39L293,49L288,57L282,60L284,72L282,85L273,87L265,97L258,113L253,124L245,130L233,130L222,136L214,147L208,157L207,173L211,185L211,195L205,202L194,206L187,211L189,221L194,228L198,239L202,250L208,255L221,257L230,264L241,275L247,289L253,300L253,308L259,313L270,314L279,322L285,331L289,343L293,354L300,359L308,359L316,353L324,354L330,361L332,372L340,380L348,382L356,380L365,373L376,375L381,384L381,392L388,397L396,396L404,399L407,407L412,414L412,423L418,428L429,428L439,423L446,417L451,407L456,397L463,392L478,393L486,386L491,377L494,367L500,359L509,352L518,345L527,337L534,329L545,317L553,307z", name: 'Africa', color: CONFIG.colors.africa, lat: 0, lon: 20, scale: 0.015, trivia: "The cradle of humankind, featuring the world's largest hot desert and longest river."},
            {svgPath: "M635,168L627,161L612,154L601,155L588,162L579,161L572,154L565,145L561,135L556,125L557,112L564,103L570,95L579,89L588,85L597,80L606,72L610,62L613,51L613,40L618,31L625,24L635,19L645,17L657,17L668,22L678,30L686,40L691,51L693,62L691,73L686,83L680,92L675,100L676,110L682,118L688,126L694,133L701,141L707,149L711,159L713,169L712,179L708,188L701,195L693,200L684,203L675,204L666,202L658,198L650,192L643,184L638,175L635,168Z", name: 'Australia', color: CONFIG.colors.australia, lat: -25, lon: 135, scale: 0.015, trivia: "An island continent known for its unique biosphere, ancient geological features, and the Great Barrier Reef."},
            {svgPath: "M439,223L433,215L428,206L423,196L418,186L413,176L410,165L409,153L411,142L416,132L422,123L429,115L437,108L445,102L454,97L463,93L473,91L483,90L493,91L503,94L512,99L520,105L527,112L533,120L538,129L542,139L545,149L547,160L548,171L547,182L545,193L542,203L538,212L533,221L527,229L520,236L512,242L503,247L493,251L483,253L473,253L463,251L454,248L445,244L439,238L435,231L439,223Z", name: 'Antarctica', color: CONFIG.colors.antarctica, lat: -82, lon: 20, scale: 0.035, trivia: "The frozen southern frontier. A land of extremes holding 90% of Earth's ice and scientific mysteries."},
            {svgPath: "M460,207L464,198L464,188L459,181L451,173L444,166L443,155L449,148L456,142L465,137L475,134L485,133L495,134L505,137L514,142L521,148L527,155L530,164L531,174L529,183L525,191L519,198L512,204L504,209L495,212L485,213L475,212L468,210L460,207Z M520,119L513,113L504,110L495,109L485,110L476,113L469,119L464,126L461,134L460,144L462,153L466,161L472,167L479,171L487,173L497,172L505,169L512,165L517,159L521,152L523,143L523,133L520,119Z", name: 'Europe', color: CONFIG.colors.europe, lat: 54, lon: 38, scale: 0.011, trivia: "A tapestry of history and culture, birthplace of Western civilization and diverse modern nations."},
            {svgPath: "M552,244L545,236L537,230L528,226L518,224L508,224L498,226L489,230L482,236L477,244L474,254L473,264L474,274L477,284L478,292L489,298L498,302L508,304L518,304L528,302L537,298L545,292L550,284L553,274L554,264L553,254L552,244Z", name: 'Asia', color: CONFIG.colors.asia, lat: 45, lon: 100, scale: 0.04, trivia: "The largest continent, featuring the highest peaks of the Himalayas and ancient, enduring civilizations."},
            {svgPath: "M229,139L224,131L217,125L209,121L200,119L190,119L181,121L173,125L166,131L161,139L158,149L157,159L158,169L161,179L166,187L173,193L181,197L190,199L200,199L209,197L217,193L224,187L229,179L232,169L233,159L232,149L229,139Z", name: 'North America', color: CONFIG.colors.northAmerica, lat: 48, lon: -100, scale: 0.03, trivia: "From the Arctic circle to tropical waters, known for innovation, natural wonders, and cultural diversity."},
            {svgPath: "M379,350L374,342L367,336L359,332L350,330L340,330L331,332L323,336L316,350L308,360L307,370L308,380L311,390L316,398L323,404L331,408L340,410L350,410L359,408L367,404L374,398L379,390L382,380L383,370L382,360L379,350Z", name: 'South America', color: CONFIG.colors.southAmerica, lat: -15, lon: -60, scale: 0.02, trivia: "Home to the Amazon Rainforest, the Andes Mountains, and a vibrant spirit of rhythm and color."},
        ];

        const svgLoader = new SVGLoader();
        const interactiveObjects = [];

        function createContinent(data) {
            const { svgPath, name, color, lat, lon, scale, trivia } = data;
            const parsedData = svgLoader.parse(`<svg><path d="${svgPath}"/></svg>`);
            
            const continentMeshGroup = new THREE.Group();

            const material = new THREE.MeshPhysicalMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                roughness: 0.2,
                metalness: 0.1,
                transmission: 0.2, // Glass-like
                thickness: 0.5,
                emissive: color,
                emissiveIntensity: 0.2,
                side: THREE.DoubleSide
            });

            parsedData.paths.forEach((path) => {
                const shapes = SVGLoader.createShapes(path);
                shapes.forEach((shape) => {
                    const geometry = new THREE.ExtrudeGeometry(shape, {
                        depth: 2, // Thicker extrude for better 3D feel
                        bevelEnabled: true,
                        bevelThickness: 0.5,
                        bevelSize: 0.5,
                        bevelSegments: 3
                    });
                    geometry.center();
                    const mesh = new THREE.Mesh(geometry, material);
                    continentMeshGroup.add(mesh);
                });
            });

            // Positioning logic
            const radius = CONFIG.radius;
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            // Create a pivot object to handle the spherical positioning easily
            const pivot = new THREE.Object3D();
            pivot.rotation.set(0, theta, 0); // Rotate around Y (longitude)

            const latPivot = new THREE.Object3D();
            latPivot.rotation.set(phi - Math.PI/2, 0, 0); // Rotate around X (latitude) - adjust for coordinate system

            // Adjust geometry position relative to pivot
            // Note: Our "lat/lon" math on the previous version was a bit direct.
            // Better to just set position on sphere surface.

            continentMeshGroup.scale.set(scale, scale, scale);

            // Proper spherical coordinates to Cartesian
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta); // wait, Three.js Z is usually depth.
            // Standard Physics: x = r sin phi cos theta, y = r sin phi sin theta, z = r cos phi.
            // But ThreeJS Y is up. So y = r cos phi. x/z plane.
            // Let's stick to setFromSphericalCoords which handles this safely.

            continentMeshGroup.position.setFromSphericalCoords(radius, phi, theta);
            continentMeshGroup.lookAt(0,0,0); // Look at center (inverted)
            // Fix orientation: Continents are flat on XY plane, need to be tangent to sphere.
            // lookAt makes Z axis point to center.
            // We need to rotate them to face OUT.
            continentMeshGroup.lookAt(new THREE.Vector3(0,0,0).sub(continentMeshGroup.position).multiplyScalar(-1)); // Look away from center

            // Store data
            continentMeshGroup.userData = {
                name,
                trivia,
                isContinent: true,
                baseColor: color,
                originalScale: scale
            };

            continentsGroup.add(continentMeshGroup);
            interactiveObjects.push(continentMeshGroup);
        }

        continentsData.forEach(createContinent);

        // --- INTERACTION LOGIC ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            if (state.animating) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                // Find the group parent
                let obj = intersects[0].object;
                while(obj.parent && !obj.userData.isContinent) {
                    obj = obj.parent;
                }

                if (state.hovered !== obj) {
                    // Unhover previous
                    if (state.hovered) animateHover(state.hovered, false);
                    // Hover new
                    state.hovered = obj;
                    animateHover(state.hovered, true);
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (state.hovered) {
                    animateHover(state.hovered, false);
                    state.hovered = null;
                    document.body.style.cursor = 'default';
                }
            }
        }

        function animateHover(obj, isHovering) {
            const scaleVal = obj.userData.originalScale * (isHovering ? 1.2 : 1.0);
            const targetEmissive = isHovering ? 0.8 : 0.2;
            const duration = 0.4;

            gsap.to(obj.scale, {
                x: scaleVal,
                y: scaleVal,
                z: scaleVal,
                duration: duration,
                ease: "back.out(1.7)"
            });

            // Just animating emissive for now to be safe and elegant
            obj.children.forEach(mesh => {
                 gsap.to(mesh.material, {
                    emissiveIntensity: targetEmissive,
                    duration: duration
                 });
            });
        }

        function onClick(event) {
            if (state.animating) return;

            // Check intersections again
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && !obj.userData.isContinent) obj = obj.parent;

                if (state.quizMode) {
                    handleQuizAnswer(obj);
                } else {
                    focusContinent(obj);
                }
            }
        }

        // --- ANIMATION CONTROLLERS ---
        function createParticleBurst(position, color) {
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = [];

            for(let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate
            const speeds = [];
            for(let i=0; i<particleCount; i++) {
                speeds.push({
                    x: (Math.random() - 0.5) * 0.2,
                    y: (Math.random() - 0.5) * 0.2,
                    z: (Math.random() - 0.5) * 0.2
                });
            }

            // Manual animation loop for particles or GSAP
            // Let's use GSAP for clean cleanup

            const positionsAttribute = geometry.attributes.position;
            const obj = { t: 0 };

            gsap.to(obj, {
                t: 1,
                duration: 1.5,
                ease: "power2.out",
                onUpdate: () => {
                    for(let i=0; i<particleCount; i++) {
                        const ix = i * 3;
                        positionsAttribute.array[ix] += speeds[i].x;
                        positionsAttribute.array[ix+1] += speeds[i].y;
                        positionsAttribute.array[ix+2] += speeds[i].z;
                    }
                    positionsAttribute.needsUpdate = true;
                    material.opacity = 1 - obj.t;
                },
                onComplete: () => {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            });
        }

        function focusContinent(obj) {
            state.animating = true;
            state.zoomed = true;
            controls.autoRotate = false;
            controls.enabled = false;

            // Particle Burst
            createParticleBurst(obj.position, obj.userData.baseColor);

            // Calculate target position in front of continent
            const targetPos = new THREE.Vector3().copy(obj.position).normalize().multiplyScalar(CONFIG.radius + 4); // Distance from surface

            // Camera Move
            gsap.to(camera.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 2,
                ease: "power3.inOut",
                onUpdate: () => camera.lookAt(0,0,0) // Keep looking at center
            });

            // UI Reveal
            showInfoCard(obj.userData);
        }

        function resetView() {
            state.animating = true;
            hideInfoCard();

            gsap.to(camera.position, {
                x: 0,
                y: 0,
                z: CONFIG.camZ,
                duration: 2,
                ease: "power3.inOut",
                onComplete: () => {
                    state.animating = false;
                    state.zoomed = false;
                    controls.autoRotate = true;
                    controls.enabled = true;
                }
            });
        }

        // --- UI HANDLERS ---
        const infoCard = document.getElementById('infoCard');
        const cardTitle = document.getElementById('cardTitle');
        const cardText = document.getElementById('cardText');
        const closeCard = document.getElementById('closeCard');
        const resetBtn = document.getElementById('resetBtn');
        const quizBtn = document.getElementById('quizBtn');

        function showInfoCard(data) {
            cardTitle.innerText = data.name;
            cardText.innerText = data.trivia;
            infoCard.classList.add('visible');

            // Enable reset button interaction if needed, though card has close
            state.animating = false; // Allow interaction after movement starts? No, wait for complete.
            // Actually, we set animating=true at start of focus. We should clear it when camera stops.
            // But for simple logic, let's unlock immediately after transition
            setTimeout(() => { state.animating = false; }, 2000);
        }

        function hideInfoCard() {
            infoCard.classList.remove('visible');
        }

        closeCard.addEventListener('click', () => {
            hideInfoCard();
            resetView();
        });

        resetBtn.addEventListener('click', () => {
            if (state.zoomed) {
                hideInfoCard();
                resetView();
            }
        });

        // --- QUIZ LOGIC ---
        const quizHud = document.getElementById('quizHud');
        const quizQuestion = document.getElementById('quizQuestion');
        const quizScoreEl = document.getElementById('quizScore');
        let quizQueue = [];

        quizBtn.addEventListener('click', toggleQuizMode);

        function toggleQuizMode() {
            state.quizMode = !state.quizMode;
            if (state.quizMode) {
                quizBtn.innerText = "Exit Exploration";
                quizBtn.style.background = "var(--glass-highlight)";
                resetView(); // Ensure we are zoomed out
                startQuiz();
            } else {
                quizBtn.innerText = "Exploration Mode";
                quizBtn.style.background = "";
                endQuiz();
            }
        }

        function startQuiz() {
            state.score = 0;
            quizScoreEl.innerText = `Score: 0`;
            quizHud.classList.add('visible');
            quizQueue = [...continentsData]; // Copy array
            nextQuestion();
        }

        function endQuiz() {
            quizHud.classList.remove('visible');
            alert(`Exploration Complete! Final Score: ${state.score}`);
        }

        function nextQuestion() {
            if (quizQueue.length === 0) {
                endQuiz();
                toggleQuizMode();
                return;
            }
            const idx = Math.floor(Math.random() * quizQueue.length);
            state.currentQuestion = quizQueue[idx];
            quizQueue.splice(idx, 1); // Remove used

            quizQuestion.innerText = `Find ${state.currentQuestion.name}`;

            // Animate question entry
            gsap.fromTo(quizQuestion, {y: 20, opacity: 0}, {y: 0, opacity: 1, duration: 0.5});
        }

        function handleQuizAnswer(obj) {
            if (obj.userData.name === state.currentQuestion.name) {
                // Correct
                state.score += 100;
                quizScoreEl.innerText = `Score: ${state.score}`;

                // Success feedback
                const flash = obj.children[0].material.emissive.getHex();
                obj.children.forEach(m => m.material.emissive.setHex(0x00ff00));
                setTimeout(() => {
                     obj.children.forEach(m => m.material.emissive.setHex(flash));
                     nextQuestion();
                }, 500);

            } else {
                // Wrong
                // Shake effect
                gsap.to(camera.position, {x: camera.position.x + 0.5, duration: 0.05, yoyo: true, repeat: 5});
            }
        }


        // --- MAIN LOOP ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update uniforms
            if(starfield.material.uniforms) starfield.material.uniforms.time.value = time;

            controls.update();
            renderer.render(scene, camera);
        }

        // --- INIT ---
        // Intro animation
        const loader = document.getElementById('loader');

        window.onload = () => {
            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 1000);

                // Camera intro zoom
                gsap.fromTo(camera.position,
                    { z: 40 },
                    { z: CONFIG.camZ, duration: 3, ease: "power4.out" }
                );
            }, 500);

            animate();
        };

    </script>
</body>
</html>
